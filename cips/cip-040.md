| cip | 40 |
| - | - |
| title | Privval Interface Extension for Arbitrary Message Signing |
| description | Extends the CometBFT privval interface to support signing arbitrary message hashes for offchain protocols. |
| author | CHAMI Rachid ([@rach-id](https://github.com/rach-id)), Evan Forbes ([evan-forbes](https://github.com/evan-forbes)) |  
| discussions-to | https://forum.celestia.org/t/cip-40-privval-interface-extension-for-arbitrary-message-signing/2102 |
| status | Draft |
| type | Standards Track |
| category | Interface |
| created | 2025-07-25 |

## Abstract

This CIP proposes extending the CometBFT privval.Message interface to support signing arbitrary message hashes. This enhancement enables validators to use their consensus keys and existing Key Management Systems (KMS) to sign offchain protocol messages, facilitating the implementation of high-throughput and low-latency gossiping protocols while maintaining backwards compatibility.

## Motivation

Celestia is implementing advanced gossiping protocols that require validators to commit to offchain messages using their consensus keys. These protocols include the Full Mesh Overlay (FMO), where validators directly connect to each other, and Vacuum!, where validators commit to blobs before block inclusion.

Current KMS implementations only support signing predefined consensus messages through the existing privval.Message interface. This limitation prevents the implementation of modern high-throughput, low-latency gossiping mechanisms that rely on validator signatures for offchain message authentication.

The proposed extension addresses this gap by allowing validators to sign arbitrary message hashes while maintaining the security properties of their existing key management infrastructure.

## Specification

The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT", "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL" in this document are to be interpreted as described in RFC 2119 and RFC 8174.

### Protocol Buffer Definitions

The following message types SHALL be added to the privval.Message interface:

```protobuf
message SignP2PMessageRequest {
  bytes  hash      = 1;
  string chain_id  = 2;
  string unique_id = 3;
}

message SignedP2PMessageResponse {
  bytes             signature = 1;
  RemoteSignerError error     = 2;
}
```

### Interface Extension

The privval.Message interface SHALL be extended to include the new message types:

```protobuf
message Message {
  oneof sum {
    PubKeyRequest            pub_key_request             = 1;
    PubKeyResponse           pub_key_response            = 2;
    SignVoteRequest          sign_vote_request           = 3;
    SignedVoteResponse       signed_vote_response        = 4;
    SignProposalRequest      sign_proposal_request       = 5;
    SignedProposalResponse   signed_proposal_response    = 6;
    PingRequest              ping_request                = 7;
    PingResponse             ping_response               = 8;
    SignP2PMessageRequest    sign_p2p_message_request    = 9;
    SignedP2PMessageResponse signed_p2p_message_response = 10;
  }
}
```

### Field Specifications

- `hash`: The SHA-256 hash of the message to be signed. This MUST be exactly 32 bytes.
- `chain_id`: The chain identifier to prevent cross-chain signature reuse.
- `unique_id`: An optional identifier for the specific protocol or message type being signed.
- `signature`: The resulting signature bytes from the signing operation.
- `error`: Error information if the signing operation fails.

### Implementation Requirements

1. KMS implementations MUST support the new message types for full compatibility.
2. The signing operation MUST use the same cryptographic key as consensus message signing.
3. Implementations MUST validate that the hash field is exactly 32 bytes.
4. The chain_id field MUST match the configured chain identifier.
5. Double-signing protection is NOT REQUIRED for P2P message signing operations.

## Rationale

### Design Decisions

**Hash-based Signing**: The interface accepts pre-hashed messages rather than raw message content to:
- Maintain consistent message size regardless of original content length
- Ensure cryptographic properties of the signed data
- Simplify KMS implementations by avoiding message content validation

**Chain ID Inclusion**: Including the chain_id prevents signature reuse across different networks, maintaining security boundaries between chains.

**Unique ID Field**: The optional unique_id field allows protocols to differentiate between different message types or contexts without requiring separate interface extensions.

**No Double-Signing Protection**: Unlike consensus messages, P2P messages do not require double-signing protection as they do not affect chain safety. This simplification reduces implementation complexity across KMS providers.

### Alternative Approaches Considered

**Message Type Enumeration**: An alternative approach would enumerate specific message types (FMO, Vacuum!, etc.). However, the hash-based approach provides greater flexibility for future protocol extensions without requiring interface changes.

**Separate Interface**: Creating a completely separate interface was considered but rejected to maintain consistency with existing KMS integrations and avoid fragmenting the signing infrastructure.

## Backwards Compatibility

This proposal is fully backwards compatible. Existing KMS implementations will continue to function normally, as the new message types use previously unused field numbers in the protobuf oneof union. Legacy implementations that do not support the new message types will return appropriate error responses, allowing calling code to handle the limitation gracefully.

## Security Considerations

### Key Reuse

This proposal reuses validator consensus keys for signing offchain messages. While this introduces additional key usage, the risk is mitigated by:

1. **Hash-based signing**: Only pre-computed hashes are signed, preventing manipulation of the signing process
2. **Chain ID scoping**: Signatures are bound to specific chain contexts
3. **No state modification**: P2P message signatures do not affect blockchain state

### Signature Verification

Applications using this interface MUST implement proper signature verification including:
- Validating the signer's public key against the validator set
- Verifying the chain_id matches the expected network
- Confirming the hash corresponds to the expected message content

### DoS Protection

KMS implementations SHOULD implement rate limiting for P2P signing requests to prevent resource exhaustion attacks against the signing infrastructure.

### Key Compromise

In the event of key compromise, the impact extends beyond consensus to any protocols using this signing interface. Monitoring systems SHOULD track unusual signing patterns across both consensus and P2P message types.

## Reference Implementation

A reference implementation is available in CometBFT PR [#5138](https://github.com/cometbft/cometbft/pull/5138). This implementation has been tested on multiple private testnets and the Mamo testnet, demonstrating practical viability.

A draft implementation for the Horcrux KMS is also available, showing integration patterns for existing key management systems.

## Copyright

Copyright and related rights waived via [CC0](https://github.com/celestiaorg/CIPs/blob/main/LICENSE).
